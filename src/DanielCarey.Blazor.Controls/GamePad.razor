@using Microsoft.AspNetCore.SignalR.Client
@using DanielCarey.Blazor.Controls.Services
@inject NavigationManager NavigationManager
@if (ShowDebug) {
    <div style="border:double 1px black;margin-bottom:.5em;width:auto;">
        <div>Index:&nbsp;@ClientGamepad?.Index</div>
        <div>Id:&nbsp;@ClientGamepad?.Id</div>
        <div>ConnectionId:&nbsp;@ClientGamepad?.ConnectionId</div>
        <div>Mapping:&nbsp;@ClientGamepad?.Mapping</div>
        @if (ClientGamepad?.Buttons.Length > 0) {
            <table style="border:1px double gray;margin-left:5em;">
                <thead>
                    <tr>Buttons</tr>
                    <tr>
                        @for (var x = 0; x < ClientGamepad?.Buttons.Count(); x++) {
                            <td style="text-align:center;min-width:2.5em;border:1px dotted gray;">@x</td>
                        }
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        @foreach (var button in ClientGamepad?.Buttons) {

                            @if (button.Pressed) {
                                <td style="text-align:center;min-width:2.5em;height:1.5em;border:1px solid black;background-color:lime"></td>
                            } else {
                                <td style="text-align:center;min-width:2.5em;height:1.5em;border:1px dotted gray;"></td>
                            }
                        }

                    </tr>
                </tbody>
            </table>
        }
        @if (ClientGamepad?.Axes.Length > 0) {
            <div style="border:1px double gray;margin-left:5em;">
                <p>Axes</p>
                @for (var x = 0; x < ClientGamepad?.Axes.Count(); x++) {
                    <div style="width:5em;text-align:center;min-width:2.5em;border:1px dotted gray;">
                        @x
                    </div>
                    <div style="width:5em;text-align:center;min-width:400px;border:1px dotted gray;">
                        @ClientGamepad?.Axes[x]
                    </div>
                }
            </div>
        }
    </div>
}

@code {

        [Parameter]
        public int Index { get; set; } = 0;

        [Parameter]
        public bool OnlyNotifyOnChange { get; set; } = true;

        [Parameter]
        public bool ShowDebug { get; set; } = false;

        [Parameter]
        public EventCallback<ClientGamePadUpdateArgs> OnClientGamepadUpdate { get; set; }

    private ClientGamepad? ClientGamepad { get; set; } = null;
    private int GamePadCount { get; set; } = 0;
    private GamepadServiceClient? _gamepadServiceClient = null;

    protected override void OnInitialized() {
        _gamepadServiceClient = new GamepadServiceClient(
        new HubConnectionBuilder()
        .WithUrl(NavigationManager.ToAbsoluteUri(GamepadServiceHub.ChannelName))
        .Build()
    );

        _gamepadServiceClient.OnUpdate += OnGamepadUpdate;
    }

    protected void OnGamepadUpdate(object sender, ClientGamepad[] gamepads) {
        bool canInvokeOnClientGamepadUpdate = false;

        // Return if the index is out of range
        if (Index < 0 || Index >= gamepads.Length) {
            StateHasChanged();
            return;
        }

        // Push the current value into PreviousValue and Set CurrentValue
        var args = new ClientGamePadUpdateArgs {
            PreviousValue = ClientGamepad,
            PreviousGamePadCount = GamePadCount,
            CurrentValue = gamepads[Index],
            CurrentGamePadCount = gamepads.Length,
        };
        ClientGamepad = gamepads[Index];
        GamePadCount = gamepads.Length;

        // if this isn't the same input device or signalr channel, return;
        if (args.PreviousValue == null ||
            args.PreviousValue.Id != args.CurrentValue.Id ||
            args.PreviousValue.ConnectionId != args.CurrentValue.ConnectionId) {
            return;
        }

        // Build the argument parameters that list the differencesbetween PreviousValue and CurrentValue
        if (args.PreviousValue != null && args.PreviousValue.Axes != null) {
            for (int x = 0; x < args.PreviousValue.Axes.Length; x++) {
                if (args.PreviousValue.Axes[x] != args.CurrentValue.Axes[x]) {
                    canInvokeOnClientGamepadUpdate = true;
                    args.ChangedAxesIndexes.Add(x);
                }
            }
        }

        if (args.PreviousValue != null && args.PreviousValue.Buttons != null) {
            for (int x = 0; x < args.PreviousValue.Buttons.Length; x++) {
                if (args.PreviousValue.Buttons[x].Value != args.CurrentValue.Buttons[x].Value) {
                    canInvokeOnClientGamepadUpdate = true;
                    args.ChangedButtonIndexes.Add(x);
                }
            }
        }

        if (OnlyNotifyOnChange == true && (args.ChangedAxesIndexes.Count > 0 || args.ChangedButtonIndexes.Count > 0)) {
            canInvokeOnClientGamepadUpdate = true;

        } else {
            canInvokeOnClientGamepadUpdate = true;
        }


        if (canInvokeOnClientGamepadUpdate && OnClientGamepadUpdate.HasDelegate) {
            OnClientGamepadUpdate.InvokeAsync(args);
        }

        StateHasChanged();
    }
}
